---
title: "Untitled"
output: html_document
date: "2025-02-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### What can we learn from these plots

It would be interesting to see if we can also learn from this information. For example Which proteins are all connected to HRAS or TP53
we can use the **adj(YourGraphNEL-object, "ProteinName")** function to see which proteins are for example connected to a certain bait.
try this function with for example TP53 as protein.

The Graph library has many functions to extract information from a network: https://bioconductor.org/packages/release/bioc/vignettes/graph/inst/doc/graph.pdf

1. We will first take a look at adj() function (page 1 last paragraph of this pdf). And extract als proteins that for example interact with HRAS

*As a sidenode: for this tutorial we used the Graph library. A more recent library is iGraph. You can convert Graph to iGraph and use iGraph for more advanced features. But more advanced is also a bit more complex. When you have become a more advanced R user I recommend to switch to iGraph or the even newer ggraph library* 

```{r}
## use the adj(.., ..) function and find the nodes that are connected to HRAS

```

##### An other interesting thing to learn is the degree of vertices. Or in other words, how many interactions does a protein have.
for this we can use the degree(GraphNEL-object) and put the output in the mydegrees variable (also on page 1 of the pdf)

*note: we have to ad graph:: before the degree function. This is new, but this is because there is also an igraph::degree function. By just using degree() R doesn't know which package to use (and you get an error)*

1. run the graph::degree function and put the outcome in a variable: **mydegrees**

This function will look at every node and determine how many connections it has and output this in a list. We can visualize this list in a histogram and see the distribution of nodes and connections.. Some nodes (proteins) will have only one connection, but some will have a lot of connections.

2. output the content of the mydegrees variable: use the following code, because we will sort it on the fly

```{r}
## run graph::degree(..) (1.)
mydegrees <- graph::degree()

## The list is probably long, but behing every protein name you see a number, representing how many interactions it has.
## we can sort this data using the R sort() function.  (2.)

sort(mydegrees)
```

**You can see that some proteins only have 1 connections whilst other have many** 

We do not see proteins with a 0. (single proteins) which is something we would not expect anyway in a pulldown (can you explain why?)

A list as shown above is informative, but sometimes its easier to just plot this information to see in one glance the distribution of connections.

1. By using the table() function in R we can convert this list in a table with names and seperate numbers 
2. Next we use the R hist() function to plot the histogram of this data.
 

```{r}
options(repr.plot.width=10, repr.plot.height=10) #this lines changes the CoCalc options to render bigger images, but now we set it back to default

## We can make this a bit more insightful
## make a table of mydegrees (hint: use the table() function) (1.)

## and plot is as an histogram (hint: his() function) (2.)

```

There is a lot of information you can extract from these networks. If you find this interesting I recommend you to dive into the world of graph-theory and networks for more information.
In this hands-on we will focus mainly on visualization and a little bit of functional annotation of sub-networks (clusters).

### Now it's up to you!
To repeat the previous steps and create the same network plot with blue bait nodes in square boxes. And to extract the 'degrees' of interactions and make the histogram. You input data is the complete network of the unfiltered data that we stored in the **interactionGraph** variable.


```{r}
## We created the nice colorful plot and also have some information about the network. But we did this on the DIS > 0.5 subset
## repeat these steps for all protein interactions (the unfiltered data) that we loaded initially.

options(repr.plot.width=20, repr.plot.height=20) #this lines changes the CoCalc options to render bigger images
## INFO/TIP: interactionGraph is the full datasetgrapNEL. and SuppS6 has all the data

## 1, make the graph (add layout)

## 2, markup of bait and prey nodes

## some additional markup stuff, set at title and subtitle.

## 3, render de graph 

## 4, calculate the degrees (graph::degree)

## 5, for plotting the Histogram reset the size of the image back to default.

```

If you have a close look at the plotted network you can see that not all parts of the graph are connected. There are separate "components"

Using the RBGL library, we can use R to make a list of all sub-graphs (components) with their respective proteins
https://bioconductor.org/packages/release/bioc/vignettes/RBGL/inst/doc/RBGL.pdf
we will use the Connected Components (chapter 3.5, pg 18 of the vignette) function **connectedComp(..)** for this. 

*(note: we don't need to use the ugraph() inside the function as our graphNEL object is already a ugraph()).*

1. run the connectedComp(..) function and store the output in a new variable: **myconnectedcomponents** use myGraph (that is the DIS >0.5) dataset
2. output the content of the variable

```{r}
## let's use our DIS > 0.5 dataset (myGraph)
## store the connected components (output of the function) in a new variable: myconnectedcompontents. (1.)

## and output the contents of myconnectedcomponents (2.)
```

Similar to what you could see in the networkplot, this output shows that, there is one very big component and several smaller components. 
And if you take a good look at each component, you can see that these consist of even smaller dense groups. Those groups we call **communities**.

In the next code-block a set of functions have been made that we have made to color all **communities** in the network-plot. There are also some additional functions made that aid in extracting the communities from the plot for further analysis later on.

1. Run the block below. You can of course have a look at the code as well and try to understand it.

```{r}
## RUN THIS BLOCK (1.)
## In the this block I provide a few functions that can be used to extract and visualize these communities better. 
## It would be a nice excersize to make these functions yourself, but that goes well beyond the scope of this tutorial. 
## Also, I took these functions from an other example. Why reinvent the wheel?

## just run this codeblock. 
## 1. To create the findcommunities(mygraph, minsize) function and a helper function and the 
## 2. findcomponent(graph, vertex) funtion.
## 3. plotcommonties(graph) function.

#
# Function to find network communities in a graph
# Returns the communities in a named vector, with nodenames as names of the vector, community number as the values.
#
findcommunities <- function(mygraphNEL) {

     # Set the counter for the number of communities:
     community_number_offset <- 0

     # First find the connected components in the graph:
     connected_components <- connectedComp(mygraphNEL)

     # For each connected component, find the communities within that connected component:
     num_connected_components <- length(connected_components)

     all_communities <- vector()

     for (i in 1:num_connected_components)
     {
        component_nodes <- connected_components[[i]]

        # Find the number of nodes in this connected component:
        num_nodes <- length(component_nodes)

        # We can only find communities if there is more than one node
        if (num_nodes > 1)
        {
            subgraph <- subGraph(component_nodes, mygraphNEL)
            found_communities <- extract_connected_graph_communities(subgraph)

            cat(max(found_communities), "communities found in subgraph", i, "\n")

            found_communities <- found_communities + community_number_offset

            all_communities <- c(all_communities, found_communities)

            community_number_offset <- max(found_communities)
        }
     }

     return(all_communities)
}

communities_to_list <- function(named_community_vector) {
    communities_list <- list()

    num_communities <- max(named_community_vector)

    for (community_num in 1:num_communities) {
        communities_list[[community_num]] <- names(named_community_vector)[named_community_vector == community_num];
    }

    return(communities_list)
}

print_communities <- function(communities) {

    if (class(communities) != "list") {
        communities <- communities_to_list(communities)
    }

    for (community in 1:length(communities)) {
        cat("Community", community, ":", communities[[community]], "\n")
    }
}

#
# Function to find network communities in a connected component of a graph
#
extract_connected_graph_communities <- function(graph) {

    # This algorithm needs an igraph.
    igraph <- graph_from_graphnel(graph)

    communities <- spinglass.community(igraph)

    # Find how many communities there are:
    communitySizes <- communities$csize
    numcommunities <- length(communitySizes)

    # Find which vertices belong to which communities:
    membership <- communities$membership

    # Get the names of vertices and use it in the membership vector
    names(membership) <- get.vertex.attribute(igraph, "name")

    return(membership)
}

findcomponent <- function(graph, vertex) {
     # Function to find the connected component that contains a particular vertex

     found <- 0
     myconnectedcomponents <- connectedComp(graph)
     numconnectedcomponents <- length(myconnectedcomponents)
     for (i in 1:numconnectedcomponents)
     {
        componenti <- myconnectedcomponents[[i]]
        numvertices <- length(componenti)
        for (j in 1:numvertices)
        {
           vertexj <- componenti[j]
           if (vertexj == vertex)
           {
              found <- 1
              return(componenti)
           }
        }
     }

     stop("ERROR: did not find vertex in the graph")
}

plotCommunities <- function(mygraphNEL)
  {
     # Function to plot network communities in a graph
     # Make a plot of the graph
     graphplot <- layoutGraph(mygraphNEL, layoutType="neato")

     # Get the names of the nodes in the graph:
     vertices <- nodes(mygraphNEL)
     numvertices <- length(vertices)

     # Now record the colour of each vertex in a vector:
     colours <- vector()
     colour <- "red"
     for (i in 1:numvertices)
     {
        vertex <- vertices[i]
        colours[vertex] <- colour
     }

    communities <- findcommunities(mygraphNEL)

    # Get a set of colours for the number of communities
    communitypallette <- rainbow(max(communities))
    
    # Get a vector that represents the communities per node
    vertexCommunities <- communities[vertices]

    # Now map colours to the community numbers, and make sure the names of the vector are set to the vertices
    # Since the order has never changed, this can be done.
    plotColours <- communitypallette[vertexCommunities]
    names(plotColours) <- vertices

    nodeRenderInfo(graphplot) = list(fill=plotColours)
    graph.par(list(nodes=list(fontsize=36), graph=list(main="PPI NETWORK", sub="communities", cex.main=1.8, cex.sub=1.4, col.sub="gray")))
    renderGraph(graphplot)
 }

```

```{r}
## With the functions we just put in memory we can obtain a colorful plot of the network and all its communities.
## for this we use the function: plotCommunities(graphNEL-object)

## lets plot the communities of our subgraph. (myGraph)

```

**that is a nice graph isn't**

1. Repeat this plotCommunities() function but now with the full dataset (interactionGraph) 

```{r}
## you can also use the plotCommunities on the complete dataset. Try it out. You will get a raport on how many components there are AND how many communities each component has.

## remember you can use: options(repr.plot.width=20, repr.plot.height=20)  #to make the images bigger
options(repr.plot.width=20, repr.plot.height=20) 

## use plotCommunities() on the complete graph (interactionGraph) (1.)
```

**Now all communities are much better visible**

There are a number functions that we have created. For example the **findcommunities(..)** functions, which is also used internally by the plotCommunities function. 

1. Run the findcommunities(..) function and store the output in a new variable: **communities**
2. Print the content of the communities variable using the **print_communities(..)** function
3. Store the lists of proteins in all communities in a new list variable: **commList** using the **communities_to_list(..)** function
4. From the output from step 2. you can see which community has has the most proteins. Output the content of that community. Let's say this is community 1, you would output this via: commList[[1]] (yes double brackets!)

The commList variable with all communities will be used again in a later part of this tutorial.


```{r}
## let's put these funtions into good use ;)

## Use the findcommunities function and store the outpunt in the communities variable (1.)

## the print_communities(communities) function will output the communities and their content (2.)

## with the communities_to_list() function we can put the content of the communities variable into a list with all communities and proteins, store the output in a variable called commList (3.)

## The commList variable contains all proteins associated to a community.  e.g. commList[[1]] will show you all proteins in community 1. (4.)
commList[[1]]
```

#### This concludes the first part of the tutorial, vizualization of the PPI networks. 
We will now continue with using a database with known information on proteins and protein networks to extract functional annotations


# In this second part of the tutorial we will try to elucidate the functions or role of the proteins in this component.
 For this we want to find the "functional annotation" of these proteins. For this we can make use of enrichment analysis.  We will do this now on this relative small dataset of this component. But the technique that we will use can be used the complete dataset and more.

 The STRING database https://string-db.org is great resource to find out information on protein protein interactions (what is already know from experiments and literature) and it contains useful analysis tools to find molecular functions of groups of protein using enrichment analysis. But be aware, there are many more databases around that can do similar things, such as the DAVID database https://david.ncifcrf.gov 
 StringDB has a nice R interface, so let's use this.
 When you loaded all the libraties in the first step of this tutorial, you also created a string_db instance. Whereas you normally load a library and use its functions directly. String communitcates to the server via this instance. This instance also provides all the functions. You therefore call a function in a slightly different way   string_db$function() 

 here is the link to the vignette: https://www.bioconductor.org/packages/release/bioc/vignettes/STRINGdb/inst/doc/STRINGdb.pdf

As is often the case when using different libraries / packages the data that we have 'as is' cannot be used by the STRING packages.
STRING for example doesn't use the protein-protein interaction information (e.g. protein A pulled-down protein B). String bases protein networks on it's own database of reported interactions. It takes your list of proteins and subsequently looks in its database if there are interactions between the other proteins in your list reported. 
Therefore we only need the list of BAITS and PREYS. 
But String doesn't use protein names directly, it wants to use its own idendifiers, aka STRING_id.

The data we will use is not the complete interaction data, but the data we obtained after filtering for DIS > 0.5, the PPIs that are specific to cancer cells.
To save you scrolling up and down: We have put these in the following variables:

``` 
Baits_sup <- SuppS6_sub$Bait
Preys_sup <- SuppS6_sub$Prey
myGraph <- makeproteingraph(Baits_sup, Preys_sup)
```

All we need to do is combine Baits and Preys into one big list.

``` allprots <- c(Baitss_sup, Preys_sup) ```

1. Create this combined list of protein and store them in the allprots variable
2. Output the allprots variable to check if it worked

```{r}
## combine both baits and preys (1.)

## output allprots (2.)
```

1. Now you can proceed to put these proteins in a data.frame variable *protein* and use as column name *proteinID*  

hint:   ..... <- data.frame(column_name = listofproteinsyouwanttoputhere)

```{r}
## let's put this list in a new data.frame with columnname: proteinID and the content of this column is the allprots list: use proteins as data.frame variable name (1.)
```

The final step is to add a column with the STRING identifiers. 

Open the vignette: https://www.bioconductor.org/packages/release/bioc/vignettes/STRINGdb/inst/doc/STRINGdb.pdf

On page 3 of the vignette (almost at the bottom) you will find an example of the *MAP* function. use *string_db$map* to create add the identifier column to our data.frame

1. In the example they create a new data.frame, but you can just send the output back to the protein variable :  protein <- string_db$..........


```{r}
## Add the string identifiers (1.) Please note that this step can take some time!
```

**dont worry if not all proteins could be mapped to a String identifier **

we can now ask String to plot a network, based on all the proteins in our dataset. 
1. On page 4 you will find the string_db function to "plot a network". Try this

```{r}
## PLot the network (1.)  Also this step can take some time

```

### OMG! this is a fuzzy hairball !
And it is also very different to our PPI plots. Still these are the same protein. But string 'determines' the protein-protein interaction not based on our PPI map, but on what it "knows" from other experiments and based on literature.. The colored edges between the nodes are indicative for the kind of evidence there is for such an interaction.

Let's highlight our BAITS in this plot. 
String offers a 'payload' mechanism for this. This means you send the list of items you want to be colored to the String server and the next time you want to create a network plot, you can send the payload_id with this plot and on the string server side it will add a 'halo' around these proteins.

For this to work we need a list of ONLY our baits (which conveniently were stored in Baits_sub). Also here we need to make a data.frame with STRING_id's. Therefore we repeat the steps as we did before to 
1. make a data.frame (which we will name UniqueBaits).  NOTE: we will use the unique() function here to make sure we remove all double names. Here is the code
    
    ``` UniqueBaits <- data.frame(baits = unique(Baits)) ``` 
    
2. add the string_id, using the string_db$map function. 



```{r}
## make the data.frame with unique baits (1.) (yes just copy paste the code)

## add the STRING_id (use the map function)

```

Now that we have our UniqueBaits list. We can create the payload_id.  
The code is already given, just run the block below.  The payload mechanism is descrived on page 6 (chapter 2)

```{r}
##  run this part..
UniqueBaits$color <- "red"  #Add a column to the UniqueBaits, that describes the 'color' of these STRING_id
payload_id <- string_db$post_payload(UniqueBaits$STRING_id, colors=UniqueBaits$color) #give this list to the string-db, which will be used when rendering a plot.

## output payload_id.. it should show a string of characters.. if you see an error something went wrong
payload_id
```

1. Create the plot again using (string_db$plot_network) but now add an additional parameter to the function:
``` string_db$plot_network( ....., payload_id=payload_id) ```


```{r}
## plot the network again using the payload_id (1.)

```

As you have seen from the PPI maps, there were several communities of proteins. Often such a community could be an indicator of a protein complex.
within string networks you can also look for '**communities**'. 
These communities are now based on the 'literature' and observed data.
On page 11 and 12, you will find an example on how String can be used to find communities (or clusters).

Lets create a cluster list first. 

1. Use the function as described on page 11/12 and store the ouput in the variable: clutersList 
2. And output some information on these clusters. The function length(..) will show how many clusters there are and lengths() will show you how many proteins per cluster there are'


```{r}
## lets create a cluster list first. Use the function as described on page 11/12 and store the ouput in the variable: clutersList  (1.)

## and output the length en lengths of this variable, which will tell us how many clusers if found (2.)
```

the output will show you how many clusters there are (length) and the number of proteins in eacht clusters (lengths()).
You will see **two** 'clusters' with a single protein. This is 'odd' as the pulldown PPI network had thesep proteins connected to a bait. It could be that these interactions are novel, found in the experiment but not yet reported elsewhere. 

In the next step we will see which proteins are in which cluster..

Now that we know we have 6 clusters, we can plot each seperate cluster. We will use a loop function for this combined with the plot function and the par() function. 
In the block below the code is already provided. It works, and you are free to experiment with it :)

```{r}
## We can use this input to plot all clusters (use the code example on page 12) but instead of using seq 1:4 do 1:6 AND mfrow=c(2,4) == 2 rows 4 columns
## hint: you can add to the plot_network() funtion , payload_id = payload_id (like I did above) this will show you the baits in the plots.. and the results might surprise you.

par(mfrow=c(2,4))
for(i in seq(1:6)){
    string_db$plot_network(clustersList[[i]], payload_id = payload_id)
}

```

It seems that most baits are in one cluster. 
We can **repeat** the step above with this cluster to further take apart this cluster. e.g. You can cluster the first cluster another time, to go even deeper! Let;s do this. 

1. Use as input the clusterList[[??]] (where ?? should be replaced with the cluster number of the cluster of interest) and store the outcome of this clustering round in the variable: **clustersList_1**

2. How many clusters and proteins are there (length() and lengths())

3. Plot all these 'sub' clusters 

```{r}
## Use as input the clusterList[[??]] (where ?? should be replaced with the cluster number of the cluster of interest) (1.)


## How many clusters and proteins are there (length() and lengths()) (2.)

## Plot all these 'sub' clusters  (3.)

```

**strikingly, the bait proteins still are mostly together. Let's try to learn more from this specific cluster and the other clusters in the next part.**
Of course you can keep going on creating sub-sub-sub-sub... clusters. But this is enough for now.

Now that we have seen that there are some really strong communities/clusters present. We would like to know if we can determine some kind of function associated to them.
1. For this we can use **Enrichment analysis (page 8)**. Where we will use as input first our initial list of proteins from before the clustering, and Store the output of the analysis in the **enrichment** variable
2. Next save the content of enrichment in an excel file. Which makes it easier to look at. (just download and open in excel): Use write_xlsx(enrichment, "NameOfYourFile.xlsx")

```{r}
## perform an enrichment analysis on the protein dataset (page 8, get_enrichment(...)) and store the output in enrichment (1.)

## save the content of this variable (data.frame) into an excel document (3.)

```

- Open the excel file, And see if you can derrive some cellular processes and functions that are related to cancer. I personally find the KEGG category (scroll way down) very interesting.

We can do the same thing for our clusters and sub-clusters. As the proteins that are in a (sub) cluster are storen in the clustersList variable (and in the clustersList1 variable etc etc).  

* clustersList[[??]] contains the proteins where the ?? needs to be replaced by the cluster number. (yes double brackets)

1. Perform an enrichment analysis on all (sub) clusters and store the output in variable (e.g): enrichment_1, enrichment_2 etc. be smart.
2. save the enrichments into excel files (also give these a smart name).
3. open the excel files (download them from files) and enjoy your analysis.

```{r}
## Now repeat the step above to generate enrichments for all (sub) clusters

```

You will see that you now find more specific functions and modules. This is because in the overall dataset all these functions are mixed, and the categories with most proteins in them are often also most significant. But not nessecarily most relevant, as GO ontologies have as a downside that it has 'more general' categorties. And these will surface first. 

Do you 'see' already some interesting categories pop-up? Maybe you see already some cancer relevant pathways or categories? And since you know which cluster the data comes from, and also the proteins in each category are there in the excel as well, you can start to find interesting candidates.


#### Back to our PPI's

We started out with a PPI network of Bait-Prey interactions.  In the communities plot (that very colorful plot earlier) you can see single proteins with a lot of proteins around them. 

For example ESR1. Let's see again which clusters there were. We stored an overview of the communities in the **communities** variable earlier. 
And we created a list of all our communities which we stored in **commList**
1. Run print_communities(..) to get a list of the communities again.

*note: the first protein in a community is the central protein to which most proteins are connected**

```{r}
## Run print_communities(..) to get a list of the communities again.
print_communities(communities)
```

With the comunities printed. Take the community with ESR1 and find the Community number. The communities are stored in commList[??]
1. Print the content of commList[[??]] to see if you indeed selected the correct one.

```{r}
## Print the content of commList[[??]] to see if you indeed selected the correct one  (1.)
```

Again we have a list of proteins in our hands. Which we can turn into a data.matrix and add the STRING_id. 
1. create a new data.frame (call it: esr2_df), with the proteins column the list of the proteins from the community
2. Add the string_id (use the map() function) to this data.frame
3. plot the network of this community. (note: add payload_id=payload_id to visualize the baits)

```{r}
## create a new data.frame (1.)

## Add the string_id (use the map() function) to this data.frame (2.)

## plot the network of this community. (3.)
```

**Are all proteins connected to ESR1? Maybe some are not connected at all. These could be novel interactions.**
Try to search for a few of these proteins in fpr example pubmed, or on ensembl.org 

On page 10 of the String DB pdf you can find the get_annotations function. 
1. Try this get_annotations(..) with for example ESR1

*note you can use the STRING_id of this protein, but with many proteins just the protein name will also work.
the string ID's are in the esr1_df you just created :)*


```{r}
## Try this get_annotations(..) (1.)
```

Of course looking at a single protein doesn't show you the complete picture.

1. Perform an enrichment analysis on this "complex" (get_enrichments) and write the outcome to an excel file.

```{r}
## Perform an enrichment analysis on this "complex" (get_enrichments) and write the outcome to an excel file. (1.)

```

#### You now have seen some basic tools to visualize and analyze protein-protein interaction. 

This is only the tip of the iceberg, but enought for one day.
Your **homework** is to have a look at some of the complexes (as shown by string) but also at some of the communities as found by the pulldown. 

* What is the general function of this group of proteins (the complex). How could they be involved, or are they involved in cancer? Can you link it to Breastcancer? 
* Some proteins are 'unconnected' in String networks, but they were found to be connected using affinity purification. Inverstigate some of these proteins and see if you can find evidence (in literature) where they are implicated in cancer. 


# Good LUCK
